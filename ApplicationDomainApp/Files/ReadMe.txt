Considerations when making use of AppDomains for security are:
	Set the application base to an appropriate directory, typically not the same as the host AppDomain.  The AppDomain’s application base is the directory that will be used as the root when resolving assembly references.  Due to this use there may be scenarios where permissions are implied based on its location (ex. Internet, intranet etc.)
	You have the ability to pass in a list of strong named assemblies that can be loaded by the AppDomain as full trust.  Consider using this list verses putting them in the GAC.  Placing an assembly in the GAC allows all AppDomains to execute it as “Full Trust”.
	Grant the minimum permissions possible that still allow the assembly to execute. 
	If there is a set of standard permissions that match your requirements of your executing assembly leverage them instead of defining your own (ex. SecurityManager.GetStandardSandbox).
	Variations in Type resolution can be setup in different AppDomains by implementing the TypeResolve event handler.  This event is fired when the CLR cannot determine the assembly that contains the specified Type.  Using this event handler you can return the Assembly from the location of your choice.
Considerations when making use of AppDomains for Memory Usage:
	Multiple AppDomains in the same process that leverage the same DLLs (assemblies) will map to the same code space in the processes memory.  This often eases the concern of some developers about base image footprints.
	If the assembly being loaded into the AppDomain contains many or large static objects or properties it may inflate the size of your process when you create it and or impact performance.  The reason for this ties back to the fact that static elements are associated with the AppDomain not the process and multiple AppDomains with the same assembly will hold multiple static versions of static objects.
Considerations when making use of AppDomains for Auditing:
	There are times when an application will terminate unexpectedly as a result of an unhandled exception.  This type of exception is known as an Unhandled Exception and can occur due to code defects and environmental changes.  In building an application that must strictly audit all system events and activities it may be desirable to log what has happened to cause the termination.  Through the implementation of the UnhandledException event handler you are notified prior to the application terminating in this situation.  In the event handler you can audit and or take corrective action such as storing state or firing out additional diagnostics structures.
	Implementation of the ProcessExit event handler will provide the consumer with up to two seconds to take the appropriate actions including state persistence and logging when the process is requested to shut down.